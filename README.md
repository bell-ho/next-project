Catch-all 라우트 [...slug].js
<br>
ex) router.query date: [2020,10,11]
<Link> 태그
replace 프로퍼티를 설정하면 새로운 페이지를 또 띄우지 않고
현재 페이지를 새 페이지로 바꿀 수 있습니다
이 경우 뒤로 갈 수 없으니 유용하게 사용할 수 있겠죠

이미지는 반드시 public 폴더에 저장해야 한다는 점 잊지 마세요
public 폴더는 Next.js 프로젝트에서는 특수한 역할을 합니다
이 폴더에 저장되어 있는
이미지나 글꼴 같은 데이터들은
Next.js에서 정적(Static)인 데이터로 작용하기 때문에
CSS나 HTML 코드에서 참조할 수 있어요
public 폴더에 이미지를 저장해 두면
Next.js에서는 그 폴더에 저장된 모든 콘텐츠를
애플리케이션의 일부로 간주하기 때문에
정적인 콘텐츠로 활용할 수 있죠
따라서 웹사이트 방문자들에게 보일 (public 폴더 밖의 파일과 폴더는 Next.js에서 접근하지 못하므로)
공공 콘텐츠를 임베드(Embed)할 때 (방문자의 브라우저에서 불러오지 못합니다)
HTML 코드에서 훨씬 수월하게 작업할 수 있게 됩니다

Next.js는 public 폴더의 모든 콘텐츠를 정적으로 처리하니
'/' + image를 붙인 요청이 작동하는 것이죠
앞에 public을 붙일 필요가 없다는 겁니다
그러니까 '/public/'이 아니라 '/'만 붙여도
public 폴더의 정적 콘텐츠로 인식되기 때문에
굳이 public 폴더로 경로를 따로 지정해주지 않아도
Next.js에서 그 콘텐츠를 그대로 처리해주는 겁니다

undefined도 로그에 나와 있는데
이는 본 컴포넌트가 두 번 렌더링되었기 때문입니다
React의 작동 방식과 라우트 데이터의 추출 방식이 그 이유죠
실질적으로 라우트 데이터를 추출하는 이 훅은
본 컴포넌트가 첫 번째 렌더링을 마친 후에 실행됩니다
즉, 컴포넌트가 처음 렌더링될 때는 해당 URL 데이터에 대한 액세스가 없죠
굳이 문제라고 하지는 않겠지만 해당 URL 데이터에 대한
액세스가 생긴 후에 Filtered Events를 살펴봐야 합니다
하나 더 염두에 둘 점은 세 번째 매개변수가 있을 때는
그러니까 이처럼 abc가 ex) 2020/10/11 있을 때는 이벤트를 찾지 않아야 합니다
최소한 필터 논리, 즉 쿼리에는 추가하지 않아야 한다는 거죠

여기서 다루는 데이터는 문자열 형식입니다
URL에 부호화되어 있어 항상 문자열이죠 하지만 우리에게 필요한 건 숫자입니다
이를 위해 numYear로 filteredYear를 변형하는데
앞에 +를 붙여 입력해 줍니다
이렇게 하면 데이터를 숫자로 변형시킬 수 있습니다

대신 Next.js에는 증분 정적 생성(ISR)이라고 하는
내장 기능이 있습니다
즉 페이지를 빌드할 때 정적으로 한 번만 생성하는 것이 아니라
배포 후에도 재배포 없이
계속 업데이트된다는 뜻입니다
따라서 페이지를 사전 생성을 하긴 하지만
최대 X초마다 들어오는 모든 요청에 대해
주어진 페이지를 Next.js가 재생성 하도록 할 수 있습니다

getStaticProps 정적 생성의 개념은 간단합니다
빌드하는 동안 페이지를 사전 생성하는 거죠
우선 getStaticProps()를 더 자세히 알아보겠습니다
보다시피 콘텍스트(context)라는 매개변수를 추가했어요
왜냐하면 이 함수는
NextJS에 의해 호출되고 인수를 받기 때문입니다
우리가 아직 거기까지 실행하지 않았을 뿐이죠
하지만 이렇게 객체를 얻고 있어요 이 객체는 인수이면서
NextJS로 실행될 때 페이지에 대한 추가 정보를 가진
매개변수라고 할 수 있습니다

하나는 notFound 키입니다
참 혹은 거짓의 불리언 값을 필요로 합니다
키를 true로 설정하면 페이지가 404 오류를 반환하며
일반 페이지 대신에 404 오류 페이지를 렌더링합니다
notFound: true를 추가하고 새로 고침하면 404 페이지가 나오죠
```javascript
return { notFound: true };
```

또한 우리는 redirect 키를 설정할 수 있습니다
redirect 키를 사용하면 사용자를 리디렉션할 수 있습니다
다시 말해 페이지 콘텐츠나 컴포넌트 콘텐츠를 렌더링하지 않고
다른 페이지, 즉 다른 라우트로 리디렉션하는 거예요
역시 데이터 페칭에 실패할 경우 필요한 설정입니다
예를 들어 데이터의 존재 여부는 둘째 치고
아예 데이터베이스 등에 액세스할 수 없다고 가정합시다
즉 상품이 없는 게 아니라 처음부터 데이터 자체가 없을 때
리디렉션을 실행하는 겁니다
destination로 설정할 라우트를 입력
```javascript
redirect: {
  destination: '/no-data'
}
```

우리는 컴포넌트 함수의 useRouter 훅을 통해
매개변수를 추출할 수 있습니다
userRouter 훅을 사용해서 router 객체에 액세스했고
router.query로 매개변수를 추출했습니다
서버상에서 혹은 getStaticProps로
구축 과정 중에 페이지를 미리 준비하려면
매개변수로의 액세스가 필요합니다
즉 getStaticProps 내부의 동적 경로 세그먼트에 액세스해서
매개변수 데이터를 통해 컴포넌트에 대한 데이터를 준비해요
그러면 컴포넌트 함수 안에도 동적 세그먼트가 필요한 게 아니면
추출할 필요가 없기 때문입니다

동적 페이지에서 오류가 나는 이유
여기서 기억해야 하는 사실은
NextJS가 모든 페이지를 사전 생성한다는 겁니다
기본적으로는 페이지를 사전 생성하는데
동적 페이지에서는 그렇지 않습니다
즉 컴포넌트 이름에 대괄호가 있을 때인데요
해당 페이지로 연결되는 동적 세그먼트가 있는 경우
기본 동작으로 페이지를 사전 생성하지 않습니다
왜 기본값이 아닐까요? 엄밀하게 따져서
이 페이지는 하나가 아니라 여러 페이지로 이루어지 때문입니다
상품 ID마다 서로 다른 페이지에 프레임 및 HTML 콘텐츠는 같고
데이터만 다르게 구성되는 겁니다
NextJS는 사전에 동적 페이지를 위해서
얼마나 많은 페이지를 미리 생성해야 하는지 알지 못합니다
그런 것을 모르니 동적 페이지는 기본적으로 사전 생성되지 못하고
대신 서버에서 항상 그때그때 생성되는 겁니다

따라서 동적 라우트의 경우 NextJS가 더 많은 정보가 필요하죠
또한 우리는 NextJS에 어떤 경로가 생성되어야 하는지
동적 페이지에서 어떤 인스턴스가 사전 생성돼야 하는지 알려줄 수 있죠
여기서 데이터만 필요한 게 아니니까요
또한 NextJS는 어떤 [id] 값이 사용 가능한지
어떤 동적 세그먼트 값을 사용할 수 있는지 알아야 합니다
그리고 어떤 값에 대한 페이지가 사전 생성되어야 하는지 알아야
NextJS가 그 페이지의 여러 인스턴스를
사전 생성할 수 있게 됩니다
페이지 파일에 추가할 수 있는 또 다른 함수를 사용합니다
그게 바로 비동기 함수인 getStaticPaths()입니다
fallback 키를 사용하면
사전 생성되어야 할 페이지가 많을 때 도움이 됩니다
fallback: true를 사용하면
여기에 포함되지 않은 페이지라도
즉 pid 매개변수에 대한 매개변수 값이 없더라도
페이지 방문 시 로딩되는 값이 유효할 수 있도록
NextJS에 요청할 수 있으니까요
다만 사전에 생성되는 건 아니고 요청이 서버에 도달하는 순간
시점에 생성되는 겁니다
이런 식으로 방문율이 높은 페이지를 사전 생성할 수 있게 되며
방문이 적은 페이지를 서버에 생성하는 것을 미뤄서
필요한 경우에만 사전 생성되게 할 수 있습니다
정말 유용할 수 있어요 하지만 문제가 있는데요
링크를 클릭하지 않고 직접 URL에 직접 입력하여
이 페이지에 새로운 요청을 보내면 에러가 발생하게 됩니다
'undefined 프로퍼티의 이름을 읽을 수 없습니다'라고 뜨네요
에러의 이유는
동적 사전 생성 기능이 즉시 끝나지 않기 때문입니다
따라서 fallback 기능을 쓰려면
컴포넌트에서 폴백 상태를 반환할 수 있게 해줘야 합니다

사전 렌더링의 두 가지 방법 정적 생성, 서버 사이드 렌더링 ssr vs ssg
둘중 하나만 해야함
우리가 작업하는 코드를 보면
서버에 도달하는 실제 요청에 접근할 필요가 없죠
하지만 정적 생성만으로는 충분하지 않을 때가 있습니다
이럴 때 실제로 서버 사이드 렌더링이 필요합니다
유입되는 모든 요청에 대한 페이지를 사전 렌더링하는 거죠
따라서 매초는 아니지만 유입되는 모든 요청에 대해서나
서버에 도달하는 특정 요청 객체에 접근할 필요가 있습니다
예를 들어 쿠키(Cookie)를 추출해야 하는 경우죠

getServerSideProps를 사용하지 않으면
Next.js에서 기본 페이지를 사전 렌더링하기 때문입니다
여기서 중요한 점은 이 페이지에 사용된 데이터는
Next.js에서 getStaticProps와 같은 함수로 준비한 것이 아니기 때문에
Next.js에서 페이지를 사전 렌더링할 때 useEffect를 거치지 않는다는 점입니다 !!
Next.js는 이 함수와 상관없이
이 컴포넌트에서 최초로 반환하는 결과로
사전 렌더링을 진행하고
거기에는 앞서 설명해 드린 이유로 인해 아무런 데이터가 없죠
따라서 그러한 초기 상태로 페이지 사전 렌더링이 이루어진 겁니다
정리하자면, 사전 렌더링이 이루어지지만 데이터가 없고
이제 데이터를 클라이언트 사이드에서 페칭하고 있기 때문입니다

Hydrate란 전송받은 JavaScript들이 이전에 보내진 HTML DOM 요소 위에서 한번 더 렌더링 하게 되면서 각각 자기 자리를 찾아가며 매칭되는 것이다. 
Hydrate 후에는 클릭과 같은 이벤트나 모듈들이 적용되어 사용자 조작이 가능해진다.
즉, Hydrate는 클라이언트 측 JavaScript가 정적 호스팅 또는 서버 측 렌더링을 통해 전달되는 정적 HTML 요소에 이벤트 핸들러를 첨부하여 동적 웹 페이지로 변환하는 기술이다.

필터링된 페이지는
클라이언트 사이드 데이터 페칭에 적합한 페이지인 것 같다고 했는데요
해당 페이지로 빠르게 이동하는 게 중요하기 때문이죠
게다가 검색 엔진 최적화에 중요한 페이지도 아니죠
제 말은 이 필터링된 이벤트 목록이
검색 엔진이 크롤링할 중요한 부분은 아니라는 거죠
중요 이벤트나 이벤트 목록 이벤트 세부 사항이 더 중요하죠
따라서 이벤트 목록 필터 페이지에
클라이언트 사이드 데이터 페칭을 적용해도 괜찮을 것 같습니다

next/image
